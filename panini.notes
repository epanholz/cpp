
== codam notes == 

only funtcion templates in the header and function 
implemantation in a seperate .cpp file just like in 
the account exercise.

NEW OPERATOR
The new operator is an operator which denotes a request 
for memory allocation on the Heap. The constructor of the
class is invoked to properly initialize this memory.

For dynamic initialization new keyword require non parameterized 
constructor if we add a parameterized constructor. So we will 
use a dummy constructor for it

FUNCTION POINTER
handy website
http://www.newty.de/fpt/fpt.html#defi

- One indirect function call is more expensive than one if condition.
- Several if conditions are more expensive than an indirect function call.

== allowed headers ==

https://en.cppreference.com/w/cpp/header

== Fixed point number stuffs == 

https://stackoverflow.com/questions/19550030/how-to-overload-operator-without-friend-function
https://en.cppreference.com/w/cpp/language/operators
https://stackoverflow.com/questions/79677/whats-the-best-way-to-do-fixed-point-math
https://embeddedartistry.com/blog/2018/07/12/simple-fixed-point-conversion-in-c/

Converting from fixed-point to floating-point is straightforward.
We take the input value and divide it by (2fractional_bits),
putting the result into a double:

inline double fixed_to_double(fixed_point_t input)
{
    return ((double)input / (double)(1 << FIXED_POINT_FRACTIONAL_BITS));
}

To convert from floating-point to fixed-point, we follow this algorithm:

Calculate x = floating_input * 2^(fractional_bits)
Round x to the nearest whole number (e.g. round(x))
Store the rounded x in an integer container

Using the algorithm above, we would implement our float-to-fixed
conversion as follows:

inline fixed_point_t double_to_fixed(double input)
{
    return (fixed_point_t)(round(input * (1 << FIXED_POINT_FRACTIONAL_BITS)));
}

== NAMESPACES ==

We can define functions and variables with the same name thanks to namespaces.

namespace owo{
	int panini = 1;
}

namespace uwu{
	int panini = 5;
}

We can just acces them like this (with the scope resolution operator):
uwu::panini 
owo::panini

== inheritance in c++ ==

The capability of a class to derive properties and characteristics from another 
class is called Inheritance. Inheritance is one of the most important features 
of Object-Oriented Programming. 

Inheritance is a feature or a process in which, new classes are created from the 
existing classes. The new class created is called “derived class” or “child class” 
and the existing class is known as the “base class” or “parent class”. 

When we say derived class inherits the base class, it means, the derived class 
inherits all the properties of the base class, without changing the properties 
of base class and may add new features to its own. These new features in the 
derived class will not affect the base class. The derived class is the specialized 
class for the base class.

== shadowing ==

Each block defines its own scope region. So what happens when we have a variable
inside a nested block that has the same name as a variable in an outer block? When
this happens, the nested variable “hides” the outer variable in areas where they
are both in scope. This is called name hiding or shadowing.

== -Wshadow ==

Warn whenever a local variable or type declaration shadows another variable, parameter,
type, class member (in C++), or instance variable (in Objective-C) or whenever a 
built-in function is shadowed. Note that in C++, the compiler warns if a local variable 
shadows an explicit typedef, but not if it shadows a struct/class/enum. If this warning 
is enabled, it includes also all instances of local shadowing. This means that
-Wno-shadow=local and -Wno-shadow=compatible-local are ignored when -Wshadow is used. 
Same as -Wshadow=global.