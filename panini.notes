
== codam notes == 

only funtcion templates in the header and function 
implemantation in a seperate .cpp file just like in 
the account exercise.

NEW OPERATOR
The new operator is an operator which denotes a request 
for memory allocation on the Heap. The constructor of the
class is invoked to properly initialize this memory.

For dynamic initialization new keyword require non parameterized 
constructor if we add a parameterized constructor. So we will 
use a dummy constructor for it

FUNCTION POINTER
handy website
http://www.newty.de/fpt/fpt.html#defi

- One indirect function call is more expensive than one if condition.
- Several if conditions are more expensive than an indirect function call.

== allowed headers ==

https://en.cppreference.com/w/cpp/header

== Fixed point number stuffs == 

https://stackoverflow.com/questions/19550030/how-to-overload-operator-without-friend-function
https://en.cppreference.com/w/cpp/language/operators
https://stackoverflow.com/questions/79677/whats-the-best-way-to-do-fixed-point-math
https://embeddedartistry.com/blog/2018/07/12/simple-fixed-point-conversion-in-c/

Converting from fixed-point to floating-point is straightforward.
We take the input value and divide it by (2fractional_bits),
putting the result into a double:

inline double fixed_to_double(fixed_point_t input)
{
    return ((double)input / (double)(1 << FIXED_POINT_FRACTIONAL_BITS));
}

To convert from floating-point to fixed-point, we follow this algorithm:

Calculate x = floating_input * 2^(fractional_bits)
Round x to the nearest whole number (e.g. round(x))
Store the rounded x in an integer container

Using the algorithm above, we would implement our float-to-fixed
conversion as follows:

inline fixed_point_t double_to_fixed(double input)
{
    return (fixed_point_t)(round(input * (1 << FIXED_POINT_FRACTIONAL_BITS)));
}

== NAMESPACES ==

We can define functions and variables with the same name thanks to namespaces.

namespace owo{
	int panini = 1;
}

namespace uwu{
	int panini = 5;
}

We can just acces them like this (with the scope resolution operator):
uwu::panini 
owo::panini

== shadowing ==

Each block defines its own scope region. So what happens when we have a variable
inside a nested block that has the same name as a variable in an outer block? When
this happens, the nested variable “hides” the outer variable in areas where they
are both in scope. This is called name hiding or shadowing.

== -Wshadow ==

Warn whenever a local variable or type declaration shadows another variable, parameter,
type, class member (in C++), or instance variable (in Objective-C) or whenever a 
built-in function is shadowed. Note that in C++, the compiler warns if a local variable 
shadows an explicit typedef, but not if it shadows a struct/class/enum. If this warning 
is enabled, it includes also all instances of local shadowing. This means that
-Wno-shadow=local and -Wno-shadow=compatible-local are ignored when -Wshadow is used. 
Same as -Wshadow=global.

== inheritance in c++ ==

The capability of a class to derive properties and characteristics from another 
class is called Inheritance. Inheritance is one of the most important features 
of Object-Oriented Programming. 

Inheritance is a feature or a process in which, new classes are created from the 
existing classes. The new class created is called “derived class” or “child class” 
and the existing class is known as the “base class” or “parent class”. 

When we say derived class inherits the base class, it means, the derived class 
inherits all the properties of the base class, without changing the properties 
of base class and may add new features to its own. These new features in the 
derived class will not affect the base class. The derived class is the specialized 
class for the base class.

== Virtual Deconstructor ==

Deleting a derived class object using a pointer of base class type that has 
a non-virtual destructor results in undefined behavior. To correct this 
situation, the base class should be defined with a virtual destructor. 
For example, following program results in undefined behavior. 

virtual destructor ensures that when derived subclasses go out of 
scope or are deleted the order of destruction of each class in a 
hierarchy is carried out correctly. 

== Virtual and Constructor ==

In C++, the constructor cannot be virtual, because when a constructor of a 
class is executed there is no virtual table in the memory, means no virtual 
pointer defined yet. So, the constructor should always be non-virtual.

== Virtual Base Class ==

For each distinct base class that is specified virtual, the most derived object 
contains only one base class subobject of that type, even if the class appears 
many times in the inheritance hierarchy (as long as it is inherited virtual
every time).

== V table ==

V-tables (or virtual tables) are how most C++ implementations do polymorphism. 
For each concrete implementation of a class, there is a table of function 
pointers to all the virtual methods. A pointer to this table (called the 
virtual table) exists as a data member in all the objects. When one calls 
a virtual method, we lookup the object's v-table and call the appropriate 
derived class method.

It's a dispatch table for all the virtual methods.

== Polymorphism ==

Polymorphism in C++ means, the same entity (function or object) behaves 
differently in different scenarios.

Consider this example:
The “ +” operator in c++ can perform two specific functions at two different 
scenarios i.e when the “+” operator is used in numbers, it performs addition.

Function overloading is also a form of polymorphism.

== Shallow Copy ==

In shallow copy, an object is created by simply copying the data of all 
variables of the original object. This works well if none of the variables 
of the object are defined in the heap section of memory. If some variables 
are dynamically allocated memory from heap section, then the copied object 
variable will also reference the same memory location.

This will create ambiguity and run-time errors, dangling pointer. Since both 
objects will reference to the same memory location, then change made by one 
will reflect those change in another object as well. Since we wanted to 
create a replica of the object, this purpose will not be filled by Shallow 
copy. 

== Deep Copy ==

In Deep copy, an object is created by copying data of all variables, and 
it also allocates similar memory resources with the same value to the object. 
In order to perform Deep copy, we need to explicitly define the copy 
constructor and assign dynamic memory as well, if required. Also, it is 
required to dynamically allocate memory to the variables in the other 
constructors, as well.

== Abstract Class ==

Defines an abstract type which cannot be instantiated, but can be used 
as a base class.

Abstract classes are used to represent general concepts (for example, 
Shape, Animal), which can be used as base classes for concrete classes 
(for example, Circle, Dog).
No objects of an abstract class can be created (except for base subobjects 
of a class derived from it) and no non-static data members of an abstract 
class can be declared.

An abstract class is, conceptually, a class that cannot be instantiated 
and is usually implemented as a class that has one or more pure virtual 
(abstract) functions.
A pure virtual function is one which must be overridden by any concrete 
(i.e., non-abstract) derived class. This is indicated in the declaration 
with the syntax " = 0" in the member function's declaration.